# 操作系统

比如微软的window操作系统、苹果的mac系统、Linux系统，还有嵌入式等各种系统

## 1. 作用
- 通过资源管理提供计算机系统的效率
- 改善人机界面向用户提供友好的工作环境

## 2. 特性
- 并发性
- 共享性
- 虚拟性
- 不确定性

## 3. 功能
- 进程管理：采用多道程序将CPU的时间合理地分配给每一个任务，包括进程控制、进程同步、进程通信和调度
- 文件管理：主要包括文件存储空间管理、目录管理、文件的读/写管理和存取控制
- 存储管理：对主存储器空间进行管理，主要包括存储分配与回收、存储保护、地址映射和主存扩充
- 设备管理：对硬件设备进行管理，包括对输入/输出设备的分配、启动、完成和回收
- 作业管理：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等


## 4. 分类
- 批处理操作系统
- 分时操作系统
- 实时操作系统
- 网络操作系统
- 分布式操作系统
- 微型计算机系统
- 嵌入式操作系统

## 5. 进程管理

进程通常由程序、数据和进程控制块组成

## 5.1 信号量机制
信号量机制是一种有效的进程同步与互斥工具，分为整型信号量、记录型信号量和信号量集机制

### 5.1.1 整型信号量
分为两种：
- 公有信号量：实现进程间的互斥，初始值为1或者是资源的数目
- 私有信号量：实现进程间的同步，初始值为0或者是某一个正整数

### 5.1.2 PV操作

低级通信方式，无法使用PV操作实现进程间的通信，因为：
- 编程难度大
- 效率低

### 5.1.3 高级通信

分为 共享存储模式、消息传递模式和管道通信

共享存储模式：相互通信的进程共享某些数据结构（或存储区）实现进程间的通信
消息传递模式：进程间的数据交换以消息为单位，程序员直接利用系统提供的一组通信命令来实现通信
管道通信：所谓管道，是指连接一个读进程和一个写进程，以实现他们之间通信的共享文件(pipe文件)，写和读都是通过这个共享文件进行

## 5.2 管程

使用信号量和PV操作来解决进程的同步互斥问题，需要在程序中的适当位置安排P、V操作，否则会造成死锁错误。

为了解决分散编程带来的困难，诞生出另一种同步机制—管程，其基本思路是采用资源集中管理的方式，由于临界区是访问共享资源的代码段，建立一个`管程`管理进程提供出的访问请求

采用这种方式对共享资源的管理就可以借助数据结构及在其上实施操作的若干过程来进行，对共享资源的申请和释放可以通过过程在数据结构上的操作来实现

## 5.3 进程调度

### 5.3.1 三级调度
- 高级调度：一个作业只需要经过一次高级调度，称为一个或者一组就绪进程
- 中级调度：交换区的哪个就绪进程可以调入内存，参与对CPU的竞争，在内存资源紧张时，必须将内存中处于阻塞状态的进程调出内存，转移到交换区，以便为调入进程腾出空间
- 低级调度：决定内存中哪一个进程可以占用CPU，对系统影响很大，是最活跃、最重要的调度程序

### 5.3.2 调度算法
- 先来先服务FCFS：优点是有利于长作业，而不利于短作业；有利于CPU繁忙的作业，不利于I/O繁忙的作业，主要用于宏观调控
- 时间片轮转：主要用于微观调控，通过分配给进程时间片来提供进程并发行和响应时间特性，从而提供资源利用率
- 优先级调度：分为静态优先级和动态优先级两种，静态优先级是创建后就不会改变，通过`进程类型`、`对资源的需求`、`用户要求`进行优先级的分配；动态优先级是在运行中还可以改变优先级，比如在就绪队列中，随着等待时间增长，优先级将提高
- 多级反馈调度：时间片轮转+优先级调度的综合与发展，调用优先级较高的进程进行先来先服务排序，然后再调用优先级较低的进程

> I/O主要就是用户的响应，需要优先响应，而对于计算型进程，比较需要最大时间片来执行，减少调度次数

### 5.3.3 死锁

死锁产生的4个必要条件：互斥条件、请求保持条件、不可剥夺条件和环路条件

死锁处理的方式：不理睬策略、预防策略、避免策略、检测与预防死锁

> 预防策略：破坏不可剥夺条件
> 避免策略：破坏环路条件，把资源分类按顺序排列进行分配，保证不形成环路
> 检测与预防死锁：资源剥夺法/撤销进程法直到解除了死锁

### 5.3.4 线程
进程：可拥有资源的独立单位 + 可独立调度和分配的基本单位

但是在进程创建、撤销和切换中，系统必须为之付出较大的时空开销，因此在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程序的提高

因此引入线程后，可以将传统进程的两个基本属性分开，使用线程作为调度和分配的基本单位，进程作为独立分配资源的单位，用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销

> 线程是进程中的一个实体，基本不包含资源，只拥有一些必不可少的资源（如程序计数器、一组寄存器和栈）等等，它可与进程中的其它线程共享进程的所有资源

线程也具有`就绪`、`运行`、`堵塞`3种基本状态，线程可以创建另一个线程，一个进程可以同时执行多个线程

线程的创建、撤销和切换可以不依赖系统调度实现，但是进程的创建、撤销和切换都必须依赖系统调度实现

## 6. 存储管理

管理对象是主存储器（简称主存或者内存）

存储管理主要的功能包括：
- 主存空间的分配和回收
- 提供主存的利用率
- 扩充主存
- 对主存信息实现有效保护

![存储器的层次结构.png](https://wbccb.github.io/Frontend-Articles/image/存储器的层次结构.png)


### 6.1 分区存储管理
早期的存储管理方案，其基本思想是把主存的用户区域划分为若干个区域，每一个区域分配给一个用户作业使用，并限定它们只能在自己的区域中运行

分为：
- 固定分区
- 可变分区
    - 最佳适应算法：找到最接近用户需求的分区，会产生细小的分区无法使用，称为外碎片
    - 最差适应算法：使用最大的空白分区
    - 首次适应算法：从低地址开始选择一个能转入用户需求的分区
    - 循环首次适应算法：每次分配都是从刚分配的空白区开始寻找一个能满足用户要求的空白区
> 可变分区会产生外碎片，解决外碎片的方法就是拼接（或者称紧凑），即向一个方向移动已经分配的作业，使那些零散的小空闲区在另外一个方向连成一片

- 可重定位分区：解决碎片问题，基本思想是移动所有已经分配好的分区，使之成为连续区域
> 当进行分区“靠拢”时会导致地址发生变化，所以有地址重定位问题

### 6.2 分区保护
> 目的是为了防止未经核准的用户访问分区

- 采用上界/下界寄存器保护：上界寄存 <= 物理地址 <= 下界寄存器
- 采用基址/限长寄存器保护：基址寄存器 <= 物理地址 < 基址寄存器 + 限长寄存器

### 6.3 分页

将一个进程的地址空间划分为：页
将主存空间划分为与`页`相同大小的若干个物理块，称为：块或者页框

在为进程分配主存时，将进程中若干页分别装入多个不相邻接的块中

系统为每一个进程建立了一张页面映射表，简称为`页表`，如下所示，页表的作用就是实现从页号到物理块号的地址映射

![页表.png](https://wbccb.github.io/Frontend-Articles/image/页表.png)


### 6.4 分段

作业的地址空间被划分为若干段，每一段都是一组完整的逻辑信息，包括主程序段、子程序段、数据段及堆栈段等

![分段管理.png](https://wbccb.github.io/Frontend-Articles/image/分段管理.png)


### 6.5 段页式

融合分页和分段的优点，
- 分页：操作系统完成，对用户是透明；不易实现共享
- 分段：段是信息的逻辑单位，其优点是易于实现段的共享，即允许多个进程共享一个或者多个段

主存：划分为大小相等的存储块
用户程序：按照程序逻辑划分为若干段，并未每段赋予一个段名，再将每一段划分为若干页，以页框为单位零散分配

![段页管理.png](https://wbccb.github.io/Frontend-Articles/image/页表.png)

### 6.6 虚拟存储

将需要执行的程序放入内存中，一些暂时还没执行的程序还是放在硬盘中，等到需要用到这些程序时，再从硬盘将程序加载到内存中


#### 6.6.1 页面置换算法

在进程运行过程中，如果发生缺页，此时主存中又无空闲块时，为了保证进程能够正常运行，必须从主存中替换一页程序



- 最佳置换算法：哪些最长时间没有被访问，则优先被替代
- 先进先出算法FIFO：淘汰最先进入的程序
- 最近最少未使用LRU：频率最低越先被替换
- 最近未用NUR：使用0和1，如果使用了，则置为1，有新的元素到来，检测是否等于1，如果是1，则置为0，如果等于0，则替换
> 可能存在一个页面一直被替换的情况



## 7. 设备管理

设备管理不仅要管理实际I/O操作的设备(如键盘、鼠标、打印机等)，还要管理诸如设备控制器、DMA控制器等等

设备管理的目标主要是如何提高设备的利用率，为用户提供方便、统一的界面。提高设备的利用率，就是提供CPU与I/O设备之间的并行操作程序，主要使用的技术有：
- 中断技术
- DMA技术
- 通道技术
- 缓冲技术

### 7.1 I/O设备管理软件
- 中断处理程序
- 设备驱动程序
- 与设备无关的系统软件
- 用户级软件

### 7.2 设备管理采用的相关技术

#### 7.2.1 通道技术
使用一个通道进行I/O任务的管理，CPU只需要向通道发出I/O命令，通道收到命令后，从主存中取出本次I/O要执行的通道程序并执行，仅当通道完成了I/O任务后才向CPU发送中断信号

#### 7.2.2 DMA技术
直接主存存取（DMA）是指数据在主存与I/O设备间直接成块传送，CPU只需要发送一个“发送块”的命令与“结束发送块”的命令，实际操作是DMA硬件完成，在此传送期间，CPU可以做别的事情

#### 7.2.3 缓冲技术

在所有的I/O设备与主存之间都使用了缓冲区来交换数据，分为单缓冲、双缓冲、多缓冲和环形缓冲

引入缓冲的主要原因有以下几个方面：
- 缓和CPU与I/O设备间速度不匹配的矛盾
- 减少对CPU的中断频率，放宽对中断响应时间的限制
- 提供CPU和I/O设备之间的并行性

![缓冲区计算时间.png](https://wbccb.github.io/Frontend-Articles/image/缓冲区计算时间.png)


### 7.3 磁盘调度

磁盘调度分为 移臂调度和旋转调度两类，先进行移臂调度，然后再进行旋转调度


#### 7.3.1 磁盘驱动调度

- 先来先服务FCFS：可能会导致平均寻道时间过长

- 最短寻道时间优先SSTF：要求访问的磁道与当前磁头所在磁道距离最近，使得每次寻道时间最短

- 扫描算法SCAN：不仅考虑要访问的磁道与当前磁道的距离，还优先考虑磁头的当前移动方向

#### 7.3.2 旋转调度算法

1. 同一磁道不同编号的扇区
2. 不同磁道不同编号的扇区
3. 不同磁道上相同编号的扇区

对于1和2：以扇区为主，先让磁头到达扇区
对于3：任选一个即可


## 8. 文件管理


### 8.1 文件

一个文件包括文件体和文件说明

- 文件体是文件真实的内容
- 文件说明是操作系统为了管理文件所用到的信息，包括文件名、文件内部标识、文件的类型、文件存储地址、文件的长度、访问权限、建立时间和访问时间等


### 8.2 文件类型

文件性质和用途：系统文件、库文件、用户文件
信息保存期限：临时文件、档案文件、永久文件
文件的保护方式：只读文件、读/写文件、可执行文件和不保护文件
> UNIX系统将文件分为：普通文件、目录文件、设备文件

> 目前常见的文件类型有：FAT、Vfat、NTFS、Ext2、HPFS等

> UNIX文件索引表项分4种寻址方式：直接寻址、一级间接寻址、二级间接寻址、三级间接寻址

### 8.3 目录
文件控制块有序集合称为文件目录

文件控制块包含以下三类信息：基本信息类、存取控制信息类、使用信息类
- 基本信息类：例如文件名、文件的物理地址、文件长度和文件块数等
- 存取控制信息类：例如文件的存取权限等
- 使用信息类：文件建立日期、最后一次修改日期等

### 8.4 存取方法和存储空间的管理

> 要将文件保存到外部存储器（简称外存或者辅存）上首先要知道存储空间的使用情况，即哪些物理块是被占用，哪些是空闲的
> 
> 因此，文件必须对磁盘空间进行管理，外存空闲空间管理的数据结构通常称为磁盘分配表


常见的空闲空间的管理方式有：空闲区表、位示图、空闲块链、成组链接法


### 8.5 文件链接

硬链接和符号链接两种

- 硬链接：不同文件名与同一个文件实体的链接，不利于文件主删除它拥有的文件，因为必须得先删除所有的硬链接
- 符号链接：符号链接建立新的文件或目录，并与原来文件或目录的路径名进行映射

### 8.6 文件系统的安全
- 系统级安全管理：不允许未经授权的用户进入系统
- 用户级安全管理：不同用户对不同文件设置不同的存取权限
- 目录级安全管理：与用户权限无关，规定只有系统核心才能有写某一些目录的权限
- 文件级安全管理：设置不同权限规定文件的操作，对于只读文件，尽管用户拥有的权限是读+写，但是仍然只能对文件进行读取操作，不能修改

> 文件系统的可靠性：转存和回复、日志文件保存修改文件的记录、文件系统的一致性（在修改文件过程中，可能某一个过程发生错误，比如内存已经修改，但是磁盘还没同步就已经被奔溃，会导致不一致性，需要增加一致性检查）

## 9. 作业管理

作业是系统为完成一个用户的计算任务（或一次事务处理）所做的工作总和。

作业由 程序、数据和作业说明书 三个部分组成

### 9.1 作业状态
- 提交
- 后备
- 执行
- 完成

![作业的状态.png](https://wbccb.github.io/Frontend-Articles/image/作业的状态.png)



### 9.2 作业调度

- 先来先服务
- 短作业优先
- 响应比高优先：`响应时间/作业执行时间`最大的优先，响应比也等于`作业周转时间/作业运行时间`=1+`作业等待时间/作业运行时间`
- 优先级调度算法
- 均衡调度算法

> 衡量作业调度算法的性能指标：T=作业最终完成时间-作业提交时间 W=T/作业执行时间
> 当用户的等待时间为0时，T=作业执行时间，性能最高

