# 一. 数据结构
> 常见的有 线性表（数组和链表）、栈和队列、串

下面将针对一些少见的数据结构进行总结分析

## 1.串

> 常见就是字符串

### 1.1 存储结构
1. 使用顺序存储结构：用一组地址连续的存储单元来存储串值的字符序列
2. 使用链式存储结构：使用链表存储串中的字符，每一个结点可以存储一个字符，也可以存储多个字符

### 1.2 模式匹配(算法难点)

#### ！！！（TODO）1.2.1 朴素的模式匹配算法

#### ！！！（TODO）1.2.2 KMP算法

## 2.矩阵

假设值相同的元素或者0元素再矩阵中的分布有一定的规律，则称此类矩阵为`特殊矩阵`，否则称为`稀疏矩阵`

特殊矩阵: 对称矩阵、三角矩阵、对角矩阵

稀疏矩阵：使用三元组表进行存储，即`(i, j, 值)`


## 3.广义表

广义表是线性表的推广，是多层次的结构，可以是子表，也可以是单元素

其中两个重要的运算是：
- 取表头`head(LS)`，可以是单元素，也可以是一个子表
- 取表尾`tail(LS)`，除表头元素外，其余元素所构成的表称为表尾

> 广义表的子表的元素也可以是一个子表

通常采用链式存储结构

## 4.树

## 5.度的概念

结点的度：一个结点的子书的个数称为该结点的度，因此叶子结点的度为0

## 6.二叉树的性质

1. 二叉树第`i`层上最多有$2^{i-1}$
2. 高度为`k`的二叉树最多有$2^k-1$个结点
3. 对于`任何`一棵二叉树，其叶子结点的数量为$n_0$，度为2的结点的个数为$n_2$，则$n_0$ = $n_2$ + 1
> 可以使用满二叉树进行推算，就算不是满二叉树，剔除掉度为1的结点后也是满二叉树

4. 具有`n`个结点的完全二叉树的深度为：$\lfloor{log_2}n\rfloor$  + 1

## 7.二叉树的存储

1. 当使用数组进行存储时，舍弃index=0，从index=1开始，第i个结点的parent是 $\lfloor{i/2}\rfloor$
2. 若`2i <= n`，则该结点n的左孩子为`2i`，否则无左孩子
3. 若`2i+1 <= n`，则该结点n的右孩子为`2i+1`，否则无右孩子

> 完全二叉树可以使用顺序存储，而一般二叉树，因为需要添加实际并不存在的“虚结点”，因此不适合使用顺序存储，会造成空间的浪费

### 7.1 线索二叉树

在左结点和右结点的基础上，增加该结点的直接前驱结点和直接后驱结点


### 7.2 最优二叉树（哈夫曼树）

#### 7.2.1 定义
带权路径长度最短的树

![tree.png](https://wbccb.github.io/Frontend-Articles/image/tree.png)


#### 7.2.2 构建流程

> 哈夫曼树的应用背景: 传输电文时想要对出现频率较高的码串进行编码（使得它路径最短），这样可以有多种组合又避免最后拼成的码串过长

![tree1.png](https://wbccb.github.io/Frontend-Articles/image/tree1.png)


## 8.图


### 8.1 定义

图中最重要的两个概念是结点和边

图G是由集合V和E构成的二元组，记作`G=(V,E)`，其中`V`是图中顶点的非空有限集合，`E`是图中边的有限集合。

### 8.2 存储结构

邻接矩阵

![graph.png](https://wbccb.github.io/Frontend-Articles/image/graph.png)


邻接链表

![graph1.png](https://wbccb.github.io/Frontend-Articles/image/graph1.png)


### 8.3 图的遍历（算法超级难点）

`深度优先遍历`：从起始点开始，不断遍历所有相邻结点，然后进行递归遍历目前结点的所有相邻结点

`广度优先遍历`：从起始点开始，使用`queue`存储起始点的所有相邻结点，然后不断加入到队列中，本质跟二叉树的广度优先遍历一样，通过每次计算`queue.length`实现一次循环

### 8.4 生成树和最小生成树（算法超级难点）

对于有n个结点的图来说，至少有n-1条边，而树中恰好有n-1条边，因此连通图的生成树就是该图的极小连通子图

> 图的生成树不是唯一的，从不同的顶点出发，选择不同的存储方式，用不同的求解方法，可以得到不同的生成树

#### 8.4.1 最小生成树著名算法（算法超级难点）

Prim算法

![最小生成树-普里姆算法.png](https://wbccb.github.io/Frontend-Articles/image/最小生成树-普里姆算法.png)

Kruskal算法


![最小生成树-普里姆算法.png](https://wbccb.github.io/Frontend-Articles/image/最小生成树-克鲁斯卡尔算法.png)


### 8.5 最短路径（算法超级难点）

Dijkstra算法
// TODO 待练习

Floyd算法
// TODO 待练习

# 二. 算法设计与分析

## 1. 查找

### 1.1 静态查找表
- 顺序查找
- 对半查找
- 分块查找

### 1.2 动态查找表
- 二叉排序树
- 平衡二叉树
- B_树
- 哈希表

#### 1.2.1 哈希表冲突解决
- 开放地址法：冲突就往后移动一位，缺点是溢出需要另外编写程序处理、容易产生聚集现象，即有一片区域的索引都有值，另外一篇的索引没有值
- 链地址法：冲突的记录创建一个链表存放冲突的值


## 2. 排序（算法种类非常多）

![排序算法性能比较.png](https://wbccb.github.io/Frontend-Articles/image/排序算法性能比较.png)



## 3. 算法概念

### 3.1 特性
- 有穷性
- 确定性
- 可行性
- 输入
- 输出

### 3.2 分治法

分治与递归就像一对孪生兄弟，经常同时应用于算法设计之中

1. 分解：将原问题分解成一系列子问题
2. 求解：递归地求解各子问题，若子问题足够小，则直接求解
3. 合并：将子问题的解合并为原问题的解

### 3.3 动态规划
1. 重复的子问题
2. 最优解

### 3.4 贪心算法
1. 最优子结构
2. 贪心选择性质

### 3.5 回溯法
1. 终止条件
2. 递归树的下一层遍历
    2.1 状态检测
    2.2 状态赋值
    2.3 回溯调用
    2.4 回复状态，继续遍历


### 3.6 分支限界法
### 3.7 概率算法
### 3.8 近似算法
### 3.9 数据挖掘算法
### 3.10 智能优化算法


