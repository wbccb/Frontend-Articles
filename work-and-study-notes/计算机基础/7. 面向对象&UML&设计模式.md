# 1. 面向对象

## 1.1 基本概念

- 类：定义对象的属性和操作方法
- 对象：类是对象之上的抽象，对象是类的具体化，是类的实例(`Instance`)
- 消息：对象之间的通信
- 继承和多态

## 1.2 面向对象的设计原则

- **单一责任原则**
- **开放-封闭原则**：软件实体应该是可扩展、开放的，但是不可修改的
- **里氏替换原则**：子类型必须能替换它们的基类型，也就是说如果一个父类实现了一个函数，子类扩展这个函数，必须能够兼容父类函数的所有细节，不能直接覆盖或者改写；里氏替换原则强调的是设计和实现要依赖于抽象而非具体；子类只能去扩展基类，而不是隐藏或者覆盖基类
- **依赖倒置原则**：抽象不应该依赖于细节，细节应该依赖于抽象，即高层模块不应该依赖于底层模块，二者都应该依赖于抽象
- **接口分离原则**：当客户类被强迫依赖那些它们不需要的接口时，则这些客户类不得不受制于这些接口。这无意间就导致了所有客户类之间的耦合。换句话说，如果一个客户类依赖了一个类，这个类包含了客户类不需要的接口，但这些接口是其他客户类所需要的，那么当其他客户类要求修改这个类时，这个修改也将影响这个客户类。通常我们都是在尽可能的避免这种耦合，所以我们需要竭尽全力地分离这些接口

> 上面是面向对象的5大原则，下面是新提出来的原则

- 重用发布等价原则：重用的粒度就是发布的粒度
- 共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其它包则不产生应该
- 共同重用原则：重用包中的一个类，就要重用包中的所有类
- 五环依赖原则：包之间的结构必须是一个直接的五环图形
- 稳定依赖原则：朝着稳定的方向进行依赖
- 稳定抽象原则：包的抽象程度和其稳定程度一致

# 2. UML

![UML各种视图.png](https://wbccb.github.io/Frontend-Articles/image/UML各种视图.png)

> 注：UML太多种类的图，单纯记忆非常有难度，应该着重于几种常见的图，然后结合示例进行掌握

# 3. 设计模式

设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案

> 针对JavaScript语言进行设计模式的讲解，而不是传统的Java或者C++语言


!(设计模式分类.png)(https://wbccb.github.io/Frontend-Articles/image/设计模式分类.png)

## 3.1 基础知识

### 3.1.1 静态语言和动态语言

静态语言在编译时就已经确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋值某一个值之后，才能具有某种类型，比如`JavaScript`

### 3.1.2 理解多态

本质上是将“做什么”和“谁去做”分离开来，要实现这一点，先要消除模块之间的耦合性


### 3.1.3 高阶函数实现AOP

AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能处理出来，这些跟业务逻辑无关的功能通常包括：
- 日志统计
- 安全控制
- 异常处理

把这些功能抽离出来之后，再通过"动态织入"的方式掺入业务逻辑模块中

这样做的好处首先是保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块


## 组合模式

- 表示对象的部分-整体层次结构
- 希望用户忽略组合中的组合对象和单个对象的不同，用户将统一使用组合中的所有对象
> 比如目录/单文件结构，我们删除目录或者删除单文件，我们希望都是一样的做法，鼠标右键就可以删除，但是实际上内部执行的删除操作是不同的，但是我们通过组合模式，封装了组合内部的不同，使得用户统一使用组合中的所有对象



## 装饰者模式

怎样为对象提供一定程度上的间接引用，实现部分都是保留对另一个对象的引用，并且向那个对象发送请求

装饰者的作用是为对象动态加入行为，可能会形成一条长长的装饰链

应用场景：
- 数据上报
- 统计函数的执行时间
- 动态改变函数参数
- 插件式的表单验证

## 享元模式
享元模式要求将对象的属性划分为内部状态与外部状态（状态这里指的是属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部和外部状态：
- 内部数据存储于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会改变
- 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享

应用场景：
- 一个程序中使用了大量的相似对象
- 由于使用了大量对象，造成了很大的内存开销
- 对象的大多数状态都可以变为可以变化的外部状态
- 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象

> 比如大数量的文件上传功能，要上传很多个文件，上千万个，每一个文件可以共同使用一个对象

### 内部状态和外部状态

有多少种内部状态，系统中最多就存在多少个共享对象

而外部状态存储在共享对象的外部，在必要时被传入共享对象来组装一个完成的对象。

### 小结

享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样，在一个存在大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题

## 代理模式

本质就是模仿原来对象，构建同样的方法提供给外部使用，对于外部来说，访问代理对象跟访问本体的效果是一样的，而代理对象可以做：
- 过滤信息
- 权限控制
- 延迟初始化
等等一系列的逻辑

- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建
- 远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象
- 虚代理：根据需要创建开销很大的对象
- 保护代理：控制对原始对象的访问，用于不同对象有不同访问权限的情况
- 智能引用代理：取代了简单的指针，它在访问对象时执行了一些附件操作，比如计算一个对象被引用的次数
- 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体。

------
> 下面开始行为设计模式

## 责任链模式

类似webpack的`loader-runner`源码，就是一个典型的责任链模式，不知道哪个结点会处理当前类型的数据，但是一旦处理，就会触发下一个结点

当然，每一次由于不知道到底哪一个结点能够处理它，因此每次都是直接将数据发送每一个结点，会造成性能损耗，因此从性能方面考虑，我们要避免过长的责任链带来的性能损耗


## 命令模式

将命令和具体命令执行者分离开来，一般是命令构造函数可以传入一个执行者对象，命令构造一般有
- 执行函数execute()
- 撤销函数undo()

> 抽离出待执行的动作以参数化某个具体的执行对象

命令设计完成后就不会再改变，然后根据传入的执行者，通过构建不同的执行者的execute()函数，达到一种命令与执行解除耦合的目的



## 解释器

给定一个语言，定义它的文法的一些表示，并定义一个解释器，这个解释器用来表示解释语言中的句子


## 迭代器

迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式，目前绝大部份语言内部都内置了迭代器

## 中介者

用一个中介对象累封装一系列对象的交互式。适用于：
- 一组对象相互之间通信方式复杂，产生的相互依赖关系结构混乱并且难以理解
- 一个对象引用其它很多对象并且直接与这些对象进行通信，导致难以复用该对象
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类


## 状态模式


变化的是状态，将每一种状态的处理行为都封装到一个单独的类中，当我们切换状态的时候，由于我们将状态封装成为独立的类，因此会将请求委托给当前的状态对象

> 比如电灯的开关，有on和off两种状态，这是两个类，当我们点击切换到on的时候，实际这个切换是在off这个类中切换的，在off这个类中处理点击的逻辑，然后切换到on类，下一次就能切换


### 使用状态模式的情景
主要适用于：
- 一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为
- 一个操作中含有庞大的多分枝的条件语句，并且这些分支的切换依赖对象的状态变化。我们可以将状态对应的行为封装成为类

> 状态变化时，在运行状态就切换它目前activeClass，然后每一个状态的类都拥有一样的方法，就可以在状态切换时实现不同逻辑分支切换，而状态的切换也是在每一个状态类中实现

### 缺点

- 每次增加一个状态，需要新增一个状态类
- 造成逻辑分散问题，无法在一个方法中知道所有逻辑



## 策略模式

### 思想
定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程
第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类

### 与状态模式的不同点

策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行

- 它们的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法
- 在状态模式中，状态和状态对应的行为是已经封装好的，状态之间的切换也早就规定好了，”改变行为“这件事发生在某一个状态类中的运行时中，对于客户来说，不需要了解这些细节。


## 模板方法

在抽象类父类中定义好多个接口，并且定义好多个接口的调用顺序，然后子类继承抽象父类，必须实现这些接口，并且不能改变这些接口的调用顺序

换句话说，抽象类父类负责设计接口调用逻辑，以及需要实现什么接口
子类只能根据抽象类父类提供的模板进行细节的补充，其它什么都做不了

因此需要用到继承！


## 访问者模式

访问者模式(Visitor Pattern)是一种行为型设计模式

访问者模式能将算法与其所作用的对象隔离开来。在访问者模式（Visitor Pattern）中，使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。


1. 意图：主要将数据结构与数据操作分离。
2. 主要解决：稳定的数据结构和易变的操作耦合问题。
3. 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让4. 这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。
5. 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。
6. 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。